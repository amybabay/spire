/*
 * Spire.
 *
 * The contents of this file are subject to the Spire Open-Source
 * License, Version 1.0 (the ``License''); you may not use
 * this file except in compliance with the License.  You may obtain a
 * copy of the License at:
 *
 * http://www.dsn.jhu.edu/spire/LICENSE.txt 
 *
 * or in the file ``LICENSE.txt'' found in this distribution.
 *
 * Software distributed under the License is distributed on an AS IS basis, 
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License 
 * for the specific language governing rights and limitations under the 
 * License.
 *
 * Spire is developed at the Distributed Systems and Networks Lab,
 * Johns Hopkins University and the Resilient Systems and Societies Lab,
 * University of Pittsburgh.
 *
 * Creators:
 *   Yair Amir            yairamir@cs.jhu.edu
 *   Trevor Aron          taron1@cs.jhu.edu
 *   Amy Babay            babay@pitt.edu
 *   Thomas Tantillo      tantillo@cs.jhu.edu 
 *   Sahiti Bommareddy    sahiti@cs.jhu.edu 
 *   Maher Khan           maherkhan@pitt.edu
 *
 * Major Contributors:
 *   Marco Platania       Contributions to architecture design 
 *   Daniel Qian          Contributions to Trip Master and IDS 
 *
 * Contributors:
 *   Samuel Beckley       Contributions to HMIs
 *
 * Copyright (c) 2017-2024 Johns Hopkins University.
 * All rights reserved.
 *
 * Partial funding for Spire research was provided by the Defense Advanced 
 * Research Projects Agency (DARPA), the Department of Defense (DoD), and the
 * Department of Energy (DoE).
 * Spire is not necessarily endorsed by DARPA, the DoD or the DoE. 
 *
 */
//***************************************************************************
//                          main.cpp  -  description
//                             -------------------
//  begin            : Wed Jun 3 11:10:58 2015
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************
//Include headers for socket management
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <signal.h>

//Include other headers
#include "pvapp.h"
#include "master_exec.h"

extern "C" {
    #include "net_wrapper.h"
    #include "def.h"
    #include "itrc.h"
    #include "openssl_rsa.h"
    #include "spu_events.h"
    #include "stdutil/stdcarr.h"
    #include "spines_lib.h"
}

// todo: comment me out. you can insert these objects as extern in your masks.
//rlModbusClient     modbus(modbusdaemon_MAILBOX,modbusdaemon_SHARED_MEMORY,modbusdaemon_SHARED_MEMORY_SIZE);
//rlSiemensTCPClient siemensTCP(siemensdaemon_MAILBOX,siemensdaemon_SHARED_MEMORY,siemensdaemon_SHARED_MEMORY_SIZE);
//rlPPIClient        ppi(ppidaemon_MAILBOX,ppidaemon_SHARED_MEMORY,ppidaemon_SHARED_MEMORY_SIZE);

unsigned int Seq_Num;
int ss_ext_spines;
struct timeval min_wait;
data_model the_model;
int Script_Running;
int Script_Button_Pushed;
int Script_Pipe[2];
stdcarr Script_History = STDCARR_STATIC_CONSTRUCT(80,0);
int Script_History_Seq;
int Script_Breaker_Index;
int Script_Breaker_Val;
sp_time Next_Button, Button_Pressed_Duration;
int My_SS_Id;
char Relay_Ext_Addrs[NUM_REPLICAS][32];




void Load_SS_Conf(int ss_id){
    FILE *fp;
    char line[255];
    char filename[100];
    int i=0;
    memset(filename,0,sizeof(filename));
    sprintf(filename,"../../common/ss%d.conf",ss_id);
    fp = fopen(filename,"r");
    while(i<NUM_REPLICAS){
        if(fgets(line, sizeof(line), fp)!=NULL){
            const char * val1=strtok(line, " ");
            const char * val2=strtok(NULL, " ");
            if(i<NUM_REPLICAS){
                strcpy(Relay_Ext_Addrs[i],val2);
            }
            
            i+=1;
        }//line
    }//while

}


extern void modelInit();

void itrc_init(int ac, char **av) 
{
    char *ip,*id;
    struct timeval now;
    // Usage check
    if (ac < 3 || ac > 4) {
        printf("Usage: %s spinesAddr SS_ID [-port=PORT] \n", av[0]);
        exit(EXIT_FAILURE);
    }

    // NET Setup
    
    gettimeofday(&now, NULL);
    My_Incarnation = now.tv_sec;
    Seq_Num = 1;
    Type = HMI_TYPE;
    My_ID = INTEGRATED_SS;
    Prime_Client_ID = MAX_NUM_SERVER_SLOTS + MAX_EMU_RTU + My_ID;
    My_IP = getIP();
    //Read keys
    OPENSSL_RSA_Init();
    OPENSSL_RSA_Read_Keys(Prime_Client_ID, RSA_CLIENT, "../../prime/bin/keys");
    // Setup connection to substation dissemination network
    sscanf(av[2],"%d",&My_SS_Id); 
    Load_SS_Conf(My_SS_Id);
    //Note: 16 is plcs used by other 3 scenarios
    int ss_spines_ext_port=SS_SPINES_EXT_BASE_PORT+((My_SS_Id-16)*10);
    int relay_ss_port=RELAY_SUBSTATION_BASE_PORT+((My_SS_Id-16)*10);
    ss_ext_spines=Spines_Sock(av[1], ss_spines_ext_port, SPINES_PRIORITY, relay_ss_port);
    if(ss_ext_spines<0){
        printf("SS HMI: Cannot connect to substation dissemination Spines\n");
        exit(EXIT_FAILURE);
    }
}

void *master_connection(void *arg) 
{
    UNUSED(arg);

    E_init();

    E_attach_fd(ss_ext_spines, READ_FD, Read_From_Master, 0, NULL, MEDIUM_PRIORITY);

    E_handle_events();

    return NULL;
}

int pvMain(PARAM *p)
{
    int ret;

    pvSendVersion(p);
    pvSetCaption(p,"power_grid");
    pvResize(p,0,1280,1024);
    //pvScreenHint(p,1024,768); // this may be used to automatically set the zoomfactor
    ret = 1;
    pvGetInitialMask(p);
    if(strcmp(p->initial_mask,"mask1") == 0) ret = 1;

    while(1) {
        if(trace) printf("show_mask%d\n", ret);
        switch(ret)
        {
            case 1:
                pvStatusMessage(p,-1,-1,-1,"mask1");
                ret = show_mask1(p);
                break;
            default:
                return 0;
        }
    }
}

#ifdef USE_INETD
int main(int ac, char **av)
{
    PARAM p;
    pthread_t tid, itid;

    signal(SIGPIPE, SIG_IGN);
    modelInit();

    printf("Single threaded server\n");
    itrc_init(ac, av);
    pthread_create(&tid, NULL, &master_connection, NULL);

    pvInit(ac,av,&p);
    /* here you may interpret ac,av and set p->user to your data */
    pvMain(&p);
    return 0;
}
#else  // multi threaded server
int main(int ac, char **av)
{
    PARAM p;
    int s;
    pthread_t tid, itid;

    signal(SIGPIPE, SIG_IGN);
    modelInit();
    printf("Multi threaded server\n");
    itrc_init(ac, av);
    pthread_create(&tid, NULL, &master_connection, NULL);

    pvInit(ac,av,&p);
    /* here you may interpret ac,av and set p->user to your data */
    while(1) {
        s = pvAccept(&p);
        if(s != -1) pvCreateThread(&p,s);
        else        break;
    }

    return 0;
}
#endif
